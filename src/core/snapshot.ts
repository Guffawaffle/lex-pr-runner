/**
 * Core snapshot generation - creates deterministic snapshot.md with metadata
 * Includes plan hash, environment fingerprint, and stable metadata
 */

import { Plan } from "../schema.js";
import { InputConfig } from "./inputs.js";
import { sha256, environmentFingerprint, lockfileHash, sha256FileRaw } from "../util/hash.js";
import { canonicalJSONStringify } from "../util/canonicalJson.js";

/**
 * Generate deterministic snapshot.md with plan metadata
 */
export function generateSnapshot(plan: Plan, inputs: InputConfig): string {
	const planJSON = canonicalJSONStringify(plan);
	const planHash = sha256(planJSON);
	const env = environmentFingerprint();
	const lockHash = lockfileHash();

	const lines: string[] = [];

	// Header
	lines.push("# Plan Snapshot");
	lines.push("");

	// Plan metadata
	lines.push("## Plan Metadata");
	lines.push(`- **Schema Version**: ${plan.schemaVersion}`);
	lines.push(`- **Target Branch**: ${plan.target}`);
	lines.push(`- **Items**: ${plan.items.length}`);
	lines.push(`- **Plan Hash (SHA-256)**: \`${planHash}\``);
	lines.push("");

	// Environment fingerprint
	lines.push("## Environment Fingerprint");
	lines.push(`- **Node.js**: ${env.node}`);
	lines.push(`- **Platform**: ${env.platform}`);
	lines.push(`- **Architecture**: ${env.arch}`);
	if (lockHash) {
		lines.push(`- **Lockfile Hash**: \`${lockHash}\``);
	}
	lines.push(`- **Environment Variables**: ${env.envKeys.length} non-sensitive keys`);
	if (env.sensitiveRedacted > 0) {
		lines.push(`- **Sensitive Variables**: ${env.sensitiveRedacted} redacted`);
	}
	lines.push("");

	// Input sources
	if (inputs.sources.length > 0) {
		lines.push("## Input Sources");
		const existingSources = inputs.sources.filter(s => s.exists);
		const missingSources = inputs.sources.filter(s => !s.exists);

		if (existingSources.length > 0) {
			lines.push("### Found:");
			for (const source of existingSources.sort((a, b) => a.file.localeCompare(b.file))) {
				lines.push(`- \`${source.file}\``);
			}
		}

		if (missingSources.length > 0) {
			lines.push("### Missing:");
			for (const source of missingSources.sort((a, b) => a.file.localeCompare(b.file))) {
				lines.push(`- \`${source.file}\` (not found)`);
			}
		}
		lines.push("");
	}

	// Plan items (if any)
	if (plan.items.length > 0) {
		lines.push("## Plan Items");
		for (const [index, item] of plan.items.entries()) {
			lines.push(`${index + 1}. **${item.name}**`);
			if (item.deps.length > 0) {
				lines.push(`   - Dependencies: ${item.deps.join(", ")}`);
			}
			if (item.gates.length > 0) {
				lines.push(`   - Gates: ${item.gates.map(g => g.name).join(", ")}`);
			}
			lines.push("");
		}
	}

	// Footer
	lines.push("---");
	lines.push(`*Generated by lex-pr-runner v${getPackageVersion()}*`);

	return lines.join("\n") + "\n";
}

/**
 * Get package version from package.json
 */
function getPackageVersion(): string {
	try {
		const fs = require("fs");
		const packageJson = JSON.parse(fs.readFileSync("package.json", "utf8"));
		return packageJson.version || "unknown";
	} catch {
		return "unknown";
	}
}

/**
 * Generate concise summary for CLI output
 */
export function generatePlanSummary(plan: Plan): string {
	const lines: string[] = [];

	lines.push(`Plan: ${plan.items.length} items targeting ${plan.target}`);
	lines.push(`Schema: ${plan.schemaVersion}`);

	if (plan.items.length > 0) {
		const withGates = plan.items.filter(item => item.gates.length > 0).length;
		const withDeps = plan.items.filter(item => item.deps.length > 0).length;

		if (withGates > 0) {
			lines.push(`Gates: ${withGates}/${plan.items.length} items have gates`);
		}
		if (withDeps > 0) {
			lines.push(`Dependencies: ${withDeps}/${plan.items.length} items have dependencies`);
		}
	}

	return lines.join(", ");
}
