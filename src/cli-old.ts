#!/usr/bin/env node
import { Command } from "commander";
import { Plan, loadPlan, validatePlan, SchemaValidationError } from "./schema.js";
import { computeMergeOrder, CycleError, UnknownDependencyError } from "./mergeOrder.js";
import { executeAllGates, GateResult } from "./gates.js";
import * as fs from "fs";
import * as path from "path";
import { spawn } from "child_process";

const program = new Command();
program.name("lex-pr").description("Lex-PR Runner CLI").version("0.1.0");

function generateSnapshot(plan: Plan): string {
	// Generate deterministic snapshot without timestamps for reproducible artifacts
	return `# Plan Snapshot

## Target Branch
${plan.target}

## Plan Items (${plan.items.length})
${plan.items.length === 0 ? 'No items in plan.' : plan.items.map((item, index) =>
	`${index + 1}. **${item.branch}** (ID: ${item.id})
   - Strategy: ${item.strategy}
   - Dependencies: ${item.needs.length > 0 ? item.needs.join(', ') : 'None'}
   ${item.sha ? `- SHA: ${item.sha}` : ''}`
).join('\n\n')}

---
*Generated by lex-pr-runner v0.1.0*
`;
}

// Schema validation command
program
	.command("schema")
	.description("Schema operations")
	.addCommand(
		new Command("validate")
			.description("Validate plan.json against schema")
			.argument("<plan-file>", "Path to plan.json file")
			.option("--json", "Output machine-readable JSON errors")
			.action((planFile: string, opts) => {
				try {
					const result = validatePlan(planFile);
					if (result.valid) {
						if (opts.json) {
							console.log(JSON.stringify({ valid: true }));
						} else {
							console.log(`✓ ${planFile} is valid`);
						}
						process.exit(0);
					} else {
						if (opts.json) {
							console.log(JSON.stringify({ valid: false, errors: result.errors }));
						} else {
							console.error(`✗ ${planFile} validation failed:`);
							result.errors?.forEach((error: string) => console.error(`  ${error}`));
						}
						process.exit(1);
					}
				} catch (error) {
					const message = error instanceof Error ? error.message : String(error);
					if (opts.json) {
						console.log(JSON.stringify({ valid: false, errors: [message] }));
					} else {
						console.error(`Error validating ${planFile}: ${message}`);
					}
					process.exit(1);
				}
			})
	);

// Merge order command
program
	.command("merge-order")
	.description("Compute dependency levels and merge order")
	.argument("<plan-file>", "Path to plan.json file")
	.option("--json", "Output JSON format")
	.action((planFile: string, opts) => {
		try {
			const plan = loadPlan(planFile);
			const levels = computeMergeOrder(plan);

			if (opts.json) {
				console.log(JSON.stringify({ levels }));
			} else {
				console.log(`Merge order for ${plan.items.length} items:`);
				levels.forEach((level: number[], index: number) => {
					console.log(`Level ${index + 1}: [${level.join(', ')}]`);
				});
			}
			process.exit(0);
		} catch (error) {
			const message = error instanceof Error ? error.message : String(error);
			if (opts.json) {
				console.log(JSON.stringify({ error: message }));
			} else {
				console.error(`Error computing merge order: ${message}`);
			}
			process.exit(1);
		}
	});

// Gate runner command
program
	.command("gate")
	.description("Run gates with capture and reporting")
	.argument("<plan-file>", "Path to plan.json file")
	.option("--json-dir <dir>", "Output directory for JSON gate results")
	.option("--timeout <ms>", "Gate timeout in milliseconds", "30000")
	.action(async (planFile: string, opts) => {
		try {
			const plan = loadPlan(planFile);
			const timeoutMs = parseInt(opts.timeout);
			const results = await executeAllGates(plan, timeoutMs);

			let hasFailures = false;

			// Output results
			for (const [itemId, gateResults] of results.entries()) {
				const item = plan.items.find((i: any) => i.id === itemId)!;
				console.log(`\nItem ${itemId} (${item.branch}):`);

				for (const result of gateResults) {
					const status = result.exitCode === 0 ? '✓' : '✗';
					const timeoutNote = result.timedOut ? ' (TIMEOUT)' : '';
					console.log(`  ${status} ${result.name} (${result.duration}ms)${timeoutNote}`);

					if (result.exitCode !== 0) {
						hasFailures = true;
						if (result.stdout) console.log(`    stdout: ${result.stdout}`);
						if (result.stderr) console.log(`    stderr: ${result.stderr}`);
					}

					// Write JSON if requested
					if (opts.jsonDir) {
						fs.mkdirSync(opts.jsonDir, { recursive: true });
						const jsonPath = path.join(opts.jsonDir, `item-${itemId}-${result.name}.json`);
						fs.writeFileSync(jsonPath, JSON.stringify(result, null, 2));
					}
				}
			}

			if (results.size === 0) {
				console.log("No gates found in plan");
			}

			process.exit(hasFailures ? 1 : 0);
		} catch (error) {
			console.error(`Error running gates: ${error instanceof Error ? error.message : String(error)}`);
			process.exit(1);
		}
	});

// Merge command (skeleton)
program
	.command("merge")
	.description("Execute merge with gate validation")
	.argument("<plan-file>", "Path to plan.json file")
	.option("--dry-run", "Dry run mode (default)", true)
	.option("--execute", "Actually perform merges")
	.action(async (planFile: string, opts) => {
		try {
			const plan = loadPlan(planFile);
			const levels = computeMergeOrder(plan);

			console.log(`Merge plan for ${plan.items.length} items → ${plan.target}`);
			console.log(`Levels: ${levels.length}`);

			// Run gates first if any exist
			const gateResults = await executeAllGates(plan, 30000);
			let hasGateFailures = false;

			for (const [itemId, results] of gateResults.entries()) {
				for (const result of results) {
					if (result.exitCode !== 0) {
						hasGateFailures = true;
						console.error(`✗ Gate '${result.name}' failed for item ${itemId}`);
					}
				}
			}

			if (hasGateFailures) {
				console.error("Cannot proceed: gates are failing");
				process.exit(1);
			}

			// Dry run mode (default)
			if (opts.dryRun && !opts.execute) {
				console.log("\n🔍 DRY RUN MODE");
				levels.forEach((level: number[], index: number) => {
					console.log(`Level ${index + 1}: would merge items [${level.join(', ')}]`);
				});
				console.log("\nUse --execute to perform actual merges");
				process.exit(0);
			}

			// Execute mode (placeholder)
			if (opts.execute) {
				console.log("🚀 EXECUTE MODE - TODO: implement actual merge operations");
				console.log("This would use a thin hosting adapter interface for git operations");
				process.exit(0);
			}
		} catch (error) {
			console.error(`Error in merge: ${error instanceof Error ? error.message : String(error)}`);
			process.exit(1);
		}
	});

// Plan generation command (for workspace compatibility)
program
	.command("plan")
	.description("Generate plan from workspace configuration")
	.option("--out <dir>", "Artifacts output dir", ".smartergpt/runner")
	.option("--json", "JSON-only mode: prints plan to stdout for CI")
	.action(async (opts) => {
		try {
			const plan = await createPlan();

			if (opts.json) {
				console.log(JSON.stringify(plan, null, 2));
				process.exit(0);
			} else {
				const outDir = opts.out as string;
				fs.mkdirSync(outDir, { recursive: true });

				const planPath = path.join(outDir, "plan.json");
				fs.writeFileSync(planPath, JSON.stringify(plan, null, 2));

				const snapshotPath = path.join(outDir, "snapshot.md");
				const snapshot = generateSnapshot(plan);
				fs.writeFileSync(snapshotPath, snapshot);

				console.log(`Wrote ${planPath}`);
				console.log(`Wrote ${snapshotPath}`);
				process.exit(0);
			}
		} catch (error) {
			console.error(`Error generating plan: ${error instanceof Error ? error.message : String(error)}`);
			process.exit(1);
		}
	});

program
	.command("doctor")
	.description("Environment and config sanity checks")
	.action(async () => {
		console.log("doctor: TODO — check git, node, package manager, and .smartergpt/*");
	});

program.parseAsync(process.argv);
